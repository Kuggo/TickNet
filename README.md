# TickNet V1.0:

**Ticknet** is a wireless communication protocol for CPUs in Minecraft. 
Here you can find all the schematics for all Network Interfaces/Nodes and their respective specifications. 

TODO explain the organization of the repository. where we can find what and stuff
To contribute link to section of community contributions

Continue reading below for a beginner's guide on Ticknet!
(For a complete specification document head over to the wiki)

---
# Ticknet in 5 mins
With Ticknet hardware one can create a cooperative network of Ticknet Nodes and communicate between them by sending and receiving packets. 
Packets are the combination of data being sent and some header that contains additional information that is useful for nodes to carry out the delivery process. 
## Payload
Data being sent is called payload and is a sequence of bytes that does not exceed the limit of 24 bytes. 
The payload can be null, meaning that a packet is only composed by the header. 
This might be useful for when a signal needs to be sent (acknowledge or ping) but no extra information is needed.
## Headers
Headers are automatically generated by the node and include (in this order): 
- A magic number. This is is a single byte that is always included so nodes know that the packet format is of Ticknet. Competing protocols will use another magic number.
- The length of the packet. It might be relevant for memory allocation purposes on the receiver side and for compatibility between other competing standards.
- The sender of the packet. That information is a single byte containing the static TN address of the node. Nodes are identified with this.
## Packet Properties
Packets sent have a few relevant properties: Consecutive packets sent between TN nodes arrive in the same order they were sent, no packets get duplicated in the process and only go missing in very specific and clearly defined scenarios:
-  The destination node is offline (turned off)
- The sender/receiver node does not have enough memory to save the transmission
## Transmission Order Queue
The packet properties can be achieved because there is a per channel order queue that tracks which nodes wish to transmit in which channel and provides the head of this queue with 1 (permission) and every other node with 0 (wait). 
This eliminates collisions, duplicates and keeps transmissions in order, which allow for a very reliable and efficient network.
## Node Interface
Nodes are controlled using a simple interface based on I/O ports. 
Each port is generally assigned to execute a type of command, or provide a certain type of information. 
Ports can be read or written to, these are different actions and will be interpreted differently by the interface.

Whenever a port finished executing a command, the busy bit will pulse.
When executing blocking operations, the pulse will indicate when the operation can proceed and stop waiting.
If the CPU wants to read without blocking, a simple SR latch that is set upon requests and reset upon busy bit pulses can be used alongside periodic checks.

| User Command | I/O Port | I/O operation  | Description                                                                                          |
| ------------ | -------- | -------------- | ---------------------------------------------------------------------------------------------------- |
| start        | cmd      | write/output 1 | Starts listening to incoming packets and starts getting ready to send.                               |
| terminate    | cmd      | write/output 2 | Stops listening to transmissions, and resets buffers.                                                |
| nextPacket   | cmd      | write/output 4 | Any value written to this will skip current received packet and get the next one (if it exists).     |
| packetCount  | cmd      | read/input     | Reads 1 if there are more packets left to read after current one, and 0 otherwise.                   |
| putByte      | data     | write/output   | Adds the byte to the current outgoing transmission (capped at 24).                                   |
| getByte      | data     | read/input     | Gets the next byte from the received transmission (or 0 if none are left).                           |
| send         | sender   | write/output   | Sets the destination node, and enqueues the current outgoing packet for transmission (0 broadcasts). |
| getSender    | sender   | read/input     | Returns the sender of current received packet (0 if no packets left).                                |
| getSize      | size     | read/input     | Returns how many bytes are left of the current received packet payload (0 if no packets left).       |

Note that if 4 ports are not available for a cpu to control, then a different version is available that only uses 2 of them at the cost of making commands take extra steps.

## Usage example


